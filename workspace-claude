#!/bin/bash
# workspace-claude - Launch Claude in isolated jj workspace
# Version: 2.2.0 (2026-02-11)
# Tested with: Claude Code 2.1.19
# Source: https://github.com/Benniphx/workspace-isolation-guide
#
# Usage: workspace-claude [options] [claude-args...]
#
# Options:
#   --branch <rev>        Base workspace on specific revision (default: main)
#   --list                List active workspaces with age
#   --sessions            List sessions with filtered user sessions
#   --resume <prefix|uuid> Resume session by workspace prefix OR Claude session UUID
#   --keep <prefix>       Protect session from cleanup
#   --unkeep <prefix>     Remove protection from session
#   --cleanup             Remove old workspaces (respects workday logic)
#   --remove <name>       Remove specific workspace
#   --version             Show version and Claude Code compatibility
#   --help                Show this help message

set -euo pipefail

WORKSPACE_CLAUDE_VERSION="2.3.0"
WORKSPACE_CLAUDE_TESTED_WITH="2.1.19"

# Auto-detect project root (first parent with .jj or .git)
find_project_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/.jj" ]] || [[ -d "$dir/.git" ]]; then
            echo "$dir"
            return 0
        fi
        dir="$(dirname "$dir")"
    done
    echo "$PWD"
}

PROJECT_ROOT="$(find_project_root)"
PROJECT_NAME="$(basename "$PROJECT_ROOT")"
WORKSPACES_DIR="${PROJECT_ROOT}-workspaces"
KEEP_WORKDAYS="${KEEP_WORKDAYS:-14}"  # Keep sessions from last N workdays (Mon-Fri)

# Unified log format: emoji + left-aligned label + message
# Usage: log_step "emoji" "Label" "message"
log_step() { printf '%s %-10s %s\n' "$1" "$2:" "$3" >&2; }
log_warn() { printf 'âš ï¸  %-10s %s\n' "Warning:" "$1" >&2; }
log_error() { printf 'âŒ %-10s %s\n' "Error:" "$1" >&2; }

show_help() {
    cat << 'EOF'
workspace-claude - Launch Claude in isolated jj workspace

USAGE:
    workspace-claude [options] [claude-args...]

OPTIONS:
    --branch <rev>        Base workspace on specific revision (default: main)
    --list                List active workspaces with filesystem age
    --sessions            List sessions with Claude session UUIDs
    --resume <id>         Resume session by workspace prefix OR Claude session UUID
    --keep <prefix>       Protect session from automatic cleanup
    --unkeep <prefix>     Remove protection from session
    --cleanup             Remove old workspaces (respects workday logic + keep flag)
    --remove <name>       Remove specific workspace
    --help                Show this help message

ENVIRONMENT:
    KEEP_WORKDAYS     Number of workdays to keep sessions (default: 2)
                      Workdays = Mon-Fri, so Friday sessions survive Monday cleanup

EXAMPLES:
    workspace-claude                              # Start new session
    workspace-claude --sessions                   # List sessions with UUIDs
    workspace-claude --resume a8f5                # Resume by workspace prefix
    workspace-claude --resume 18fcd521-0457-...   # Resume by Claude session UUID
    workspace-claude --keep a8f5                  # Protect session from cleanup
    workspace-claude --branch feat/x              # Start from specific branch

SESSION METADATA:
    Each workspace has a .session-meta.json with:
    - created: Creation timestamp
    - last_active: Last activity timestamp
    - description: Optional description
    - keep: Protection flag (survives cleanup if true)

VERSION:
    workspace-claude $WORKSPACE_CLAUDE_VERSION
    Tested with Claude Code $WORKSPACE_CLAUDE_TESTED_WITH
EOF
}

show_version() {
    echo "workspace-claude $WORKSPACE_CLAUDE_VERSION"
    echo "Tested with: Claude Code $WORKSPACE_CLAUDE_TESTED_WITH"
    echo ""

    # Check current Claude Code version
    local current_cc_version
    current_cc_version=$(command claude --version 2>/dev/null | head -1 | grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+' || echo "unknown")

    echo "Installed Claude Code: $current_cc_version"

    # Compare versions
    if [[ "$current_cc_version" != "unknown" && "$current_cc_version" != "$WORKSPACE_CLAUDE_TESTED_WITH" ]]; then
        echo ""
        echo "âš ï¸  Version mismatch detected!"
        echo "   Check CHANGELOG.md for compatibility notes:"
        echo "   https://github.com/Benniphx/workspace-isolation-guide/blob/main/CHANGELOG.md"
    fi
}

# Calculate cutoff date based on workdays (Mon-Fri)
# Returns Unix timestamp of the cutoff date
calculate_cutoff_date() {
    local keep_days="${1:-$KEEP_WORKDAYS}"
    local now_ts=$(date +%s)
    local day_of_week=$(date +%u)  # 1=Monday, 7=Sunday
    local days_to_subtract=0
    local workdays_counted=0

    # Count backwards through calendar days until we've passed enough workdays
    while [[ $workdays_counted -lt $keep_days ]]; do
        ((days_to_subtract++))
        local check_ts=$((now_ts - days_to_subtract * 86400))
        local check_dow=$(date -r "$check_ts" +%u 2>/dev/null || date -d "@$check_ts" +%u 2>/dev/null)
        # Only count Mon-Fri as workdays
        if [[ $check_dow -ge 1 && $check_dow -le 5 ]]; then
            ((workdays_counted++))
        fi
    done

    # Return timestamp at start of the cutoff day
    local cutoff_ts=$((now_ts - days_to_subtract * 86400))
    # Normalize to start of day
    local cutoff_date=$(date -r "$cutoff_ts" +%Y-%m-%d 2>/dev/null || date -d "@$cutoff_ts" +%Y-%m-%d 2>/dev/null)
    date -j -f "%Y-%m-%d" "$cutoff_date" +%s 2>/dev/null || date -d "$cutoff_date" +%s 2>/dev/null
}

# Create session metadata file
create_session_meta() {
    local workspace_path="$1"
    local session_id="$2"
    local meta_file="${workspace_path}/.session-meta.json"

    cat > "$meta_file" << EOF
{
  "created": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "last_active": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "description": "",
  "keep": false,
  "session_id": "$session_id"
}
EOF
}

# Update session metadata field
update_session_meta() {
    local workspace_path="$1"
    local field="$2"
    local value="$3"
    local meta_file="${workspace_path}/.session-meta.json"

    if [[ ! -f "$meta_file" ]]; then
        log_warn "No metadata file found: $meta_file"
        return 1
    fi

    # Use jq if available, otherwise sed for simple cases
    if command -v jq &>/dev/null; then
        local tmp_file=$(mktemp)
        if [[ "$value" == "true" || "$value" == "false" ]]; then
            jq ".$field = $value" "$meta_file" > "$tmp_file"
        else
            jq ".$field = \"$value\"" "$meta_file" > "$tmp_file"
        fi
        mv "$tmp_file" "$meta_file"
    else
        # Fallback: simple sed for common cases
        if [[ "$field" == "keep" ]]; then
            sed -i.bak "s/\"keep\": [^,]*/\"keep\": $value/" "$meta_file"
            rm -f "${meta_file}.bak"
        elif [[ "$field" == "last_active" ]]; then
            sed -i.bak "s/\"last_active\": \"[^\"]*\"/\"last_active\": \"$value\"/" "$meta_file"
            rm -f "${meta_file}.bak"
        fi
    fi
}

# Read session metadata field
read_session_meta() {
    local workspace_path="$1"
    local field="$2"
    local meta_file="${workspace_path}/.session-meta.json"

    if [[ ! -f "$meta_file" ]]; then
        echo ""
        return
    fi

    if command -v jq &>/dev/null; then
        jq -r ".$field // empty" "$meta_file" 2>/dev/null
    else
        # Fallback: grep for simple cases
        grep -o "\"$field\": *\"[^\"]*\"" "$meta_file" 2>/dev/null | sed 's/.*: *"\([^"]*\)"/\1/' || \
        grep -o "\"$field\": *[^,}]*" "$meta_file" 2>/dev/null | sed 's/.*: *//' | tr -d ' '
    fi
}

# Find workspace by prefix
find_workspace_by_prefix() {
    local prefix="$1"
    local matches=()

    [[ -d "$WORKSPACES_DIR" ]] || return 1

    for ws in "$WORKSPACES_DIR"/session-*"$prefix"*; do
        [[ -d "$ws" ]] && matches+=("$ws")
    done

    if [[ ${#matches[@]} -eq 0 ]]; then
        log_error "No workspace found matching: $prefix"
        return 1
    elif [[ ${#matches[@]} -gt 1 ]]; then
        log_error "Multiple workspaces match '$prefix':"
        for m in "${matches[@]}"; do
            echo "  $(basename "$m")" >&2
        done
        return 1
    fi

    echo "${matches[0]}"
}

# Resolve short UUID prefix â†’ full session UUID via sessions-index.json
resolve_session_uuid_prefix() {
    local prefix="$1"
    local claude_projects_dir="$HOME/.claude/projects"
    command -v jq &>/dev/null || { log_error "jq required for UUID resolution"; return 1; }
    local matches=()
    for index_file in "$claude_projects_dir"/*/sessions-index.json; do
        [[ -f "$index_file" ]] || continue
        while IFS= read -r uuid; do
            [[ -n "$uuid" ]] && matches+=("$uuid")
        done < <(jq -r --arg prefix "$prefix" \
            '.entries[] | select(.sessionId | startswith($prefix)) | .sessionId' \
            "$index_file" 2>/dev/null)
    done

    if [[ ${#matches[@]} -eq 0 ]]; then
        return 1
    elif [[ ${#matches[@]} -gt 1 ]]; then
        log_error "Multiple sessions match UUID prefix '$prefix':"
        for m in "${matches[@]}"; do
            echo "  $m" >&2
        done
        return 1
    fi

    echo "${matches[0]}"
}

# Resolve Claude session UUID â†’ workspace path via sessions-index.json
resolve_session_uuid() {
    local uuid="$1"
    local claude_projects_dir="$HOME/.claude/projects"
    command -v jq &>/dev/null || { log_error "jq required for UUID resolution"; return 1; }
    for index_file in "$claude_projects_dir"/*/sessions-index.json; do
        [[ -f "$index_file" ]] || continue
        local path
        path=$(jq -r --arg id "$uuid" \
            '.entries[] | select(.sessionId == $id) | .projectPath' \
            "$index_file" 2>/dev/null | head -1)
        if [[ -n "$path" && "$path" != "null" && -d "$path" ]]; then
            echo "$path"
            return 0
        fi
    done
    return 1
}

# Set/unset keep flag on session
keep_session() {
    local prefix="$1"
    local keep_value="${2:-true}"

    local workspace_path
    workspace_path=$(find_workspace_by_prefix "$prefix") || return 1

    local meta_file="${workspace_path}/.session-meta.json"
    if [[ ! -f "$meta_file" ]]; then
        # Create metadata if missing
        local session_id=$(basename "$workspace_path")
        create_session_meta "$workspace_path" "$session_id"
    fi

    update_session_meta "$workspace_path" "keep" "$keep_value"
    update_session_meta "$workspace_path" "last_active" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

    if [[ "$keep_value" == "true" ]]; then
        log_step "ðŸ”’" "Keep" "$(basename "$workspace_path")"
    else
        log_step "ðŸ”“" "Unkeep" "$(basename "$workspace_path")"
    fi
}

# Check if session is a real user session (not memory-observer, sub-agent, or system)
is_user_session() {
    local first_prompt="$1"
    local msg_count="$2"

    # Filter out empty or very short sessions
    [[ -z "$first_prompt" ]] && return 1
    [[ "$first_prompt" == "No prompt" ]] && return 1
    [[ "${msg_count:-0}" -lt 3 ]] && return 1

    # Filter out memory-observer sessions
    if [[ "$first_prompt" == *"Claude-Mem"* ]] || \
       [[ "$first_prompt" == *"memory agent"* ]] || \
       [[ "$first_prompt" == *"observer"* ]] || \
       [[ "$first_prompt" == *"observed_from_primary"* ]] || \
       [[ "$first_prompt" == *"You are a specialized"* ]]; then
        return 1
    fi

    # Filter out task notifications and system messages
    if [[ "$first_prompt" == "<task-notification>"* ]] || \
       [[ "$first_prompt" == "PROGRESS SUMMARY"* ]] || \
       [[ "$first_prompt" == *"<what_"* ]]; then
        return 1
    fi

    return 0
}

# List sessions from all workspaces with filtering
list_sessions() {
    echo "$PROJECT_NAME Workspace Sessions"
    echo "=================================="
    echo ""
    printf "  %-19s | %-8s | %-7s | %-11s | %-4s | %-6s | %s\n" "Workspace" "UUID" "Status" "Modified" "Msgs" "Keep" "First Prompt"
    printf "  %-19s-+-%-8s-+-%-7s-+-%-11s-+-%-4s-+-%-6s-+-%s\n" "-------------------" "--------" "-------" "-----------" "----" "------" "----------------------------------------"

    local sessions_found=false
    local claude_projects_dir="$HOME/.claude/projects"
    local seen_workspaces=()

    # Scan all workspace session indices
    for index_dir in "$claude_projects_dir"/-*-"${PROJECT_NAME}-workspaces-session-"*; do
        [[ -d "$index_dir" ]] || continue
        local index_file="$index_dir/sessions-index.json"
        [[ -f "$index_file" ]] || continue

        # Extract workspace ID from directory name
        local workspace_id=$(basename "$index_dir" | grep -o 'session-[0-9]*-[a-f0-9]*' | head -1)
        [[ -z "$workspace_id" ]] && continue

        local short_id="${workspace_id#session-}"
        local workspace_path="${WORKSPACES_DIR}/${workspace_id}"

        # Check workspace status
        local ws_status="orphan"
        local keep_flag="no"
        if [[ -d "$workspace_path" ]]; then
            ws_status="active"
            keep_flag=$(read_session_meta "$workspace_path" "keep")
            [[ "$keep_flag" == "true" ]] && keep_flag="YES" || keep_flag="no"
        fi

        # Parse sessions-index.json for real user sessions (only show most recent per workspace)
        if command -v jq &>/dev/null; then
            local best_session_uuid=""
            local best_msg_count=0
            local best_modified=""
            local best_prompt=""

            while IFS='|' read -r session_uuid first_prompt msg_count modified; do
                [[ -z "$first_prompt" ]] && continue

                # Filter out memory-observer and sub-agent sessions
                if ! is_user_session "$first_prompt" "$msg_count"; then
                    continue
                fi

                # Keep the session with most messages (likely the main conversation)
                if [[ "${msg_count:-0}" -gt "$best_msg_count" ]]; then
                    best_session_uuid="$session_uuid"
                    best_msg_count="$msg_count"
                    best_modified="$modified"
                    best_prompt="$first_prompt"
                fi

            done < <(jq -r '.entries[] | "\(.sessionId)|\(.firstPrompt | gsub("\n"; " ")[:100])|\(.messageCount)|\(.modified)"' "$index_file" 2>/dev/null)

            # Only show if we found a valid session
            if [[ -n "$best_prompt" ]]; then
                sessions_found=true

                # Format date from ISO timestamp
                local mod_date=$(echo "$best_modified" | cut -d'T' -f1)

                # Truncate UUID to 8 chars for display
                local uuid_short="${best_session_uuid:0:8}"

                # Truncate first prompt for display
                local prompt_preview="${best_prompt:0:40}"
                [[ ${#best_prompt} -gt 40 ]] && prompt_preview="${prompt_preview}..."

                printf "  %-19s | %-8s | %-7s | %-11s | %4s | %-6s | %s\n" \
                    "$short_id" "$uuid_short" "$ws_status" "$mod_date" "$best_msg_count" "$keep_flag" "$prompt_preview"
            fi
        else
            # Fallback without jq - just show workspace exists
            sessions_found=true
            local date_part="${short_id:0:8}"
            local formatted_date="${date_part:0:4}-${date_part:4:2}-${date_part:6:2}"
            printf "  %-19s | %-8s | %-7s | %-11s | %4s | %-6s | %s\n" \
                "$short_id" "?" "$ws_status" "$formatted_date" "?" "$keep_flag" "(install jq for UUIDs)"
        fi
    done

    # Also list workspaces without Claude sessions yet
    if [[ -d "$WORKSPACES_DIR" ]]; then
        for ws in "$WORKSPACES_DIR"/session-*; do
            [[ -d "$ws" ]] || continue
            local ws_name=$(basename "$ws")
            local short_id="${ws_name#session-}"

            # Check if we already listed this workspace
            local index_dir="$claude_projects_dir/-Users-benniphx-Documents-jobrad-${PROJECT_NAME}-workspaces-${ws_name}"
            [[ -d "$index_dir" ]] && continue

            sessions_found=true
            local keep_flag=$(read_session_meta "$ws" "keep")
            [[ "$keep_flag" == "true" ]] && keep_flag="YES" || keep_flag="no"

            local date_part="${short_id:0:8}"
            local formatted_date="${date_part:0:4}-${date_part:4:2}-${date_part:6:2}"

            printf "  %-19s | %-8s | %-7s | %-11s | %4s | %-6s | %s\n" \
                "$short_id" "-" "new" "$formatted_date" "0" "$keep_flag" "(no sessions yet)"
        done
    fi

    if [[ "$sessions_found" == "false" ]]; then
        echo "  (no sessions found)"
    fi

    echo ""
    echo "Legend: active = workspace exists, orphan = workspace deleted, new = no Claude sessions yet"
    echo ""
    echo "Resume by prefix: workspace-claude --resume <prefix>"
    echo "Resume by UUID:   workspace-claude --resume <full-uuid>  (or: claude --resume <uuid>)"
}

# Resume existing session
resume_session() {
    local identifier="$1"
    shift
    local claude_args=("$@")

    local workspace_path
    local session_uuid=""

    # UUID-Format erkennen (8-4-4-4-12 hex)
    if [[ "$identifier" =~ ^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$ ]]; then
        session_uuid="$identifier"
        workspace_path=$(resolve_session_uuid "$identifier") || {
            log_error "No workspace found for session UUID: $identifier"
            return 1
        }
    else
        # Try workspace prefix first, fall back to UUID prefix
        workspace_path=$(find_workspace_by_prefix "$identifier" 2>/dev/null) || {
            # Not a workspace prefix - try as UUID prefix
            session_uuid=$(resolve_session_uuid_prefix "$identifier") || {
                log_error "No workspace or session found for: $identifier"
                return 1
            }
            workspace_path=$(resolve_session_uuid "$session_uuid") || {
                log_error "No workspace found for session UUID: $session_uuid"
                return 1
            }
        }
    fi

    local session_id=$(basename "$workspace_path")

    # Update last_active
    if [[ -f "${workspace_path}/.session-meta.json" ]]; then
        update_session_meta "$workspace_path" "last_active" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
    fi

    print_startup_summary "$workspace_path" "${session_id#session-}" "" "$session_uuid"
    echo "" >&2

    cd "$workspace_path"
    eval "$(mise activate bash 2>/dev/null)" || true
    direnv allow 2>/dev/null || true

    # Bei UUID den --resume mit UUID weitergeben, sonst nur --resume
    if [[ -n "$session_uuid" ]]; then
        exec command claude --dangerously-skip-permissions --resume "$session_uuid" ${claude_args[@]+"${claude_args[@]}"}
    else
        exec command claude --dangerously-skip-permissions --resume ${claude_args[@]+"${claude_args[@]}"}
    fi
}

cleanup_old_workspaces() {
    [[ -d "$WORKSPACES_DIR" ]] || return 0

    # Auto-recover stale working copy before cleanup (uses jj workspace forget)
    if jj st 2>&1 | grep -q "working copy is stale"; then
        jj workspace update-stale 2>/dev/null || true
    fi

    local count=0
    local skipped=0
    local cutoff_ts
    cutoff_ts=$(calculate_cutoff_date "$KEEP_WORKDAYS")

    log_step "ðŸ§¹" "Cleanup" "keeping sessions from last $KEEP_WORKDAYS workday(s)"
    log_step "ðŸ“…" "Cutoff" "$(date -r "$cutoff_ts" +%Y-%m-%d 2>/dev/null || date -d "@$cutoff_ts" +%Y-%m-%d 2>/dev/null)"

    for ws in "$WORKSPACES_DIR"/session-*; do
        [[ -d "$ws" ]] || continue
        local ws_name=$(basename "$ws")

        # Check keep flag in metadata
        local keep_flag=$(read_session_meta "$ws" "keep")
        if [[ "$keep_flag" == "true" ]]; then
            log_step "ðŸ”’" "Keep" "$ws_name"
            ((skipped++)) || true
            continue
        fi

        # Use last_active from metadata if available, otherwise filesystem mtime
        local last_active=$(read_session_meta "$ws" "last_active")
        local ws_ts

        if [[ -n "$last_active" ]]; then
            # Parse ISO date from metadata
            ws_ts=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$last_active" +%s 2>/dev/null || \
                    date -d "$last_active" +%s 2>/dev/null || \
                    stat -f %m "$ws" 2>/dev/null || stat -c %Y "$ws" 2>/dev/null)
        else
            ws_ts=$(stat -f %m "$ws" 2>/dev/null || stat -c %Y "$ws" 2>/dev/null)
        fi

        if [[ $ws_ts -lt $cutoff_ts ]]; then
            log_step "ðŸ—‘ï¸ " "Remove" "$ws_name"
            (cd "$PROJECT_ROOT" && jj workspace forget "$ws_name" 2>/dev/null || true)
            rm -rf "$ws"
            ((count++)) || true
        fi
    done

    [[ $count -gt 0 ]] && log_step "ðŸ§¹" "Cleanup" "$count workspace(s) removed"
    [[ $skipped -gt 0 ]] && log_step "ðŸ”’" "Keep" "$skipped workspace(s) skipped"
    return 0
}

create_workspace() {
    local session_id="$1"
    local base_rev="${2:-main}"
    local short_id="${session_id:0:19}"  # YYYYMMDDHHMMSS-xxxx (includes random)
    local workspace_name="session-${short_id}"
    local workspace_path="${WORKSPACES_DIR}/${workspace_name}"

    mkdir -p "$WORKSPACES_DIR"
    cleanup_old_workspaces

    if [[ -d "$workspace_path" ]]; then
        log_step "ðŸ“" "Workspace" "exists: $workspace_name"
        echo "$workspace_path"
        return 0
    fi

    log_step "ðŸ”¨" "Create" "$workspace_name (based on $base_rev)"

    cd "$PROJECT_ROOT"

    # Auto-recover stale working copy (happens when other workspaces modify the repo)
    # Note: jj config `snapshot.auto-update-stale = true` handles this globally,
    # but we keep explicit recovery as defense-in-depth for safety.
    if jj st 2>&1 | grep -q "working copy is stale"; then
        log_step "ðŸ”„" "Recover" "stale working copy"
        jj workspace update-stale 2>/dev/null || log_warn "Could not update stale working copy"
    fi

    log_step "ðŸ“¥" "Fetch" "latest from remote"
    jj git fetch 2>/dev/null || {
        # Fallback: fetch without working copy interaction
        jj --ignore-working-copy git fetch 2>/dev/null || log_warn "Could not fetch"
    }

    # Update local main bookmark to match origin (jj fetch doesn't do this automatically)
    if [[ "$base_rev" == "main" ]]; then
        log_step "ðŸ”„" "Sync" "main â†’ origin"
        jj bookmark set main -r main@origin 2>/dev/null || \
            jj --ignore-working-copy bookmark set main -r main@origin 2>/dev/null || \
            log_warn "Could not sync main"
    fi

    jj workspace add "$workspace_path" -r "$base_rev" 2>/dev/null || {
        log_error "Failed to create workspace"
        return 1
    }

    # Copy environment files
    for f in .envrc .env .env.local; do
        [[ -f "$PROJECT_ROOT/$f" ]] && cp "$PROJECT_ROOT/$f" "$workspace_path/"
    done

    # Create session metadata
    create_session_meta "$workspace_path" "$workspace_name"

    cd "$workspace_path"

    # Setup based on project type
    if [[ -f "pyproject.toml" ]]; then
        log_step "ðŸ" "Python" "running uv sync"
        mise trust "$workspace_path" 2>/dev/null || true
        eval "$(mise activate bash 2>/dev/null)" || true
        uv sync >/dev/null 2>&1 || log_warn "uv sync failed"
    elif [[ -f "package.json" ]]; then
        log_step "ðŸ“¦" "Node" "running npm install"
        npm install >/dev/null 2>&1 || log_warn "npm install failed"
    fi

    # Remove macOS extended attributes that block Python execution in sandbox
    # (com.apple.provenance is set when files are copied and can cause [Errno 1])
    find "$workspace_path/.claude" -name "*.py" -exec xattr -d com.apple.provenance {} \; 2>/dev/null || true
    find "$workspace_path/.claude" -name "*.sh" -exec xattr -d com.apple.provenance {} \; 2>/dev/null || true

    # Link workspace memory to global memory (shared across all sessions)
    setup_memory_symlink "$workspace_path"

    log_step "âœ…" "Ready" "$workspace_path"
    echo "$workspace_path"
}

list_workspaces() {
    echo "Active workspaces for $PROJECT_NAME:"
    echo "======================================"

    if [[ ! -d "$WORKSPACES_DIR" ]]; then
        echo "  (none)"
        return
    fi

    for ws in "$WORKSPACES_DIR"/session-*; do
        [[ -d "$ws" ]] || continue
        local ws_name=$(basename "$ws")
        local mtime=$(stat -f %m "$ws" 2>/dev/null || stat -c %Y "$ws" 2>/dev/null)
        local age_hours=$(( ($(date +%s) - mtime) / 3600 ))
        echo "  $ws_name (age: ${age_hours}h)"
    done

    echo ""
    echo "jj workspaces:"
    (cd "$PROJECT_ROOT" && jj workspace update-stale 2>/dev/null; jj workspace list 2>/dev/null) || echo "  (not a jj repo)"
}

# Pre-create Claude project dir with memory symlink to global memory
# This ensures all workspace sessions share one persistent memory store
setup_memory_symlink() {
    local workspace_path="$1"
    local global_memory="$HOME/.claude/projects/$(echo "$HOME" | tr '/' '-')/memory"

    # Only proceed if global memory exists
    [[ -d "$global_memory" ]] || return 0

    # Calculate Claude project dir for this workspace
    local project_dir_name=$(echo "$workspace_path" | tr '/' '-')
    local claude_project_dir="$HOME/.claude/projects/${project_dir_name}"
    local memory_dir="${claude_project_dir}/memory"

    mkdir -p "$claude_project_dir"

    # If memory already exists as a real dir with content, skip
    if [[ -d "$memory_dir" && ! -L "$memory_dir" ]]; then
        local file_count=$(find "$memory_dir" -type f 2>/dev/null | wc -l | tr -d ' ')
        if [[ "$file_count" -gt 0 ]]; then
            log_warn "Memory dir has existing content, skipping symlink: $memory_dir"
            return 0
        fi
        rmdir "$memory_dir" 2>/dev/null || return 0
    fi

    # Create symlink if not already one
    if [[ ! -L "$memory_dir" ]]; then
        ln -s "$global_memory" "$memory_dir"
        log_step "ðŸ§ " "Memory" "linked to global"
    fi
}

print_startup_summary() {
    local workspace_path="$1"
    local session_label="${2:-}"
    local base_rev="${3:-}"
    local session_uuid="${4:-}"

    echo "" >&2

    # Project + Session
    log_step "ðŸš€" "Project" "$PROJECT_NAME"
    if [[ -n "$session_label" ]]; then
        local session_info="$session_label"
        [[ -n "$base_rev" ]] && session_info+=" (base: $base_rev)"
        [[ -n "$session_uuid" ]] && session_info+=" [${session_uuid:0:8}â€¦]"
        log_step "ðŸ·ï¸ " "Session" "$session_info"
    fi

    # Workspace
    log_step "ðŸ“" "Workspace" "$workspace_path"

    # Beads
    if [[ -d "$PROJECT_ROOT/.beads" ]]; then
        export BEADS_DIR="$PROJECT_ROOT/.beads"
        log_step "ðŸ“‹" "Beads" "$BEADS_DIR (central)"
    fi

    # Memory
    local claude_project_dir_name
    claude_project_dir_name=$(echo "$workspace_path" | tr '/' '-')
    local memory_dir="$HOME/.claude/projects/${claude_project_dir_name}/memory"
    if [[ -L "$memory_dir" ]]; then
        local file_count
        file_count=$(find -L "$memory_dir" -type f 2>/dev/null | wc -l | tr -d ' ')
        log_step "ðŸ§ " "Memory" "symlinked â†’ global ($file_count files)"
    elif [[ -d "$memory_dir" ]]; then
        local file_count
        file_count=$(find "$memory_dir" -type f 2>/dev/null | wc -l | tr -d ' ')
        log_step "ðŸ§ " "Memory" "local ($file_count files)"
    else
        log_step "ðŸ§ " "Memory" "not configured"
    fi

    # Python / Node environment
    if [[ -f "$workspace_path/pyproject.toml" ]]; then
        if [[ -d "$workspace_path/.venv" ]]; then
            local py_version
            py_version=$("$workspace_path/.venv/bin/python" --version 2>/dev/null | grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+' || echo "?")
            log_step "ðŸ" "Python" ".venv ready ($py_version)"
        else
            log_step "ðŸ" "Python" "missing .venv"
        fi
    elif [[ -f "$workspace_path/package.json" ]]; then
        if [[ -d "$workspace_path/node_modules" ]]; then
            local node_version
            node_version=$(node --version 2>/dev/null || echo "?")
            log_step "ðŸ“¦" "Node" "node_modules ready ($node_version)"
        else
            log_step "ðŸ“¦" "Node" "missing node_modules"
        fi
    fi

    # jj info
    if [[ -d "$workspace_path/.jj" ]] || [[ -d "$PROJECT_ROOT/.jj" ]]; then
        local change_id bookmark_info jj_info
        change_id=$(cd "$workspace_path" && jj log -r @ --no-graph -T 'change_id.short()' 2>/dev/null || echo "?")
        bookmark_info=$(cd "$workspace_path" && jj log -r @ --no-graph -T 'bookmarks' 2>/dev/null || echo "")
        jj_info="@${change_id}"
        if [[ -n "$bookmark_info" ]]; then
            jj_info+=" (${bookmark_info})"
        else
            jj_info+=" (on ${BASE_REV:-main})"
        fi
        log_step "ðŸ”€" "jj" "$jj_info"
    fi

    # CLAUDE.md
    if [[ -f "$workspace_path/CLAUDE.md" ]]; then
        log_step "ðŸ“„" "CLAUDE.md" "found"
    else
        log_step "ðŸ“„" "CLAUDE.md" "not found"
    fi

    # Tools
    local tools_parts=()
    local mise_ver direnv_ver
    mise_ver=$(mise --version 2>/dev/null | head -1 | grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+' || true)
    direnv_ver=$(direnv version 2>/dev/null || true)
    [[ -n "$mise_ver" ]] && tools_parts+=("mise $mise_ver")
    [[ -n "$direnv_ver" ]] && tools_parts+=("direnv $direnv_ver")
    if [[ ${#tools_parts[@]} -gt 0 ]]; then
        log_step "ðŸ”§" "Tools" "$(printf '%s' "${tools_parts[0]}")$(printf ', %s' "${tools_parts[@]:1}" 2>/dev/null || true)"
    fi
}

remove_workspace() {
    local workspace_name="$1"
    local workspace_path="${WORKSPACES_DIR}/${workspace_name}"

    if [[ ! -d "$workspace_path" ]]; then
        log_error "Workspace not found: $workspace_name"
        return 1
    fi

    log_step "ðŸ—‘ï¸ " "Remove" "$workspace_name"
    (cd "$PROJECT_ROOT" && jj workspace forget "$workspace_name" 2>/dev/null || true)
    rm -rf "$workspace_path"
    log_step "âœ…" "Done" "workspace removed"
}

# Parse arguments
BASE_REV="main"
ACTION="run"
REMOVE_TARGET=""
RESUME_PREFIX=""
KEEP_PREFIX=""
CLAUDE_ARGS=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        --branch)
            BASE_REV="$2"
            shift 2
            ;;
        --list)
            ACTION="list"
            shift
            ;;
        --sessions)
            ACTION="sessions"
            shift
            ;;
        --resume)
            ACTION="resume"
            RESUME_PREFIX="$2"
            shift 2
            ;;
        --keep)
            ACTION="keep"
            KEEP_PREFIX="$2"
            shift 2
            ;;
        --unkeep)
            ACTION="unkeep"
            KEEP_PREFIX="$2"
            shift 2
            ;;
        --cleanup)
            ACTION="cleanup"
            shift
            ;;
        --remove)
            ACTION="remove"
            REMOVE_TARGET="$2"
            shift 2
            ;;
        --version|-v)
            ACTION="version"
            shift
            ;;
        --help|-h)
            ACTION="help"
            shift
            ;;
        *)
            CLAUDE_ARGS+=("$1")
            shift
            ;;
    esac
done

case "$ACTION" in
    help)
        show_help
        ;;
    version)
        show_version
        ;;
    list)
        list_workspaces
        ;;
    sessions)
        list_sessions
        ;;
    resume)
        resume_session "$RESUME_PREFIX" ${CLAUDE_ARGS[@]+"${CLAUDE_ARGS[@]}"}
        ;;
    keep)
        keep_session "$KEEP_PREFIX" "true"
        ;;
    unkeep)
        keep_session "$KEEP_PREFIX" "false"
        ;;
    cleanup)
        cleanup_old_workspaces
        ;;
    remove)
        remove_workspace "$REMOVE_TARGET"
        ;;
    run)
        session_id="$(date +%Y%m%d%H%M%S)-$(openssl rand -hex 4)"

        workspace_path=$(create_workspace "$session_id" "$BASE_REV")

        if [[ ! -d "$workspace_path" ]]; then
            log_error "Failed to create workspace"
            exit 1
        fi

        print_startup_summary "$workspace_path" "${session_id:0:19}" "$BASE_REV"
        echo "" >&2

        cd "$workspace_path"
        eval "$(mise activate bash 2>/dev/null)" || true
        direnv allow 2>/dev/null || true

        # Skip trust dialog - workspaces are created from trusted repo
        exec command claude --dangerously-skip-permissions ${CLAUDE_ARGS[@]+"${CLAUDE_ARGS[@]}"}
        ;;
esac
