#!/bin/bash
# workspace-claude - Launch Claude in isolated jj workspace
# Version: 2.1.0 (2026-02-10)
# Tested with: Claude Code 2.1.19
# Source: https://github.com/Benniphx/workspace-isolation-guide
#
# Usage: workspace-claude [options] [claude-args...]
#
# Options:
#   --branch <rev>    Base workspace on specific revision (default: main)
#   --list            List active workspaces with age
#   --sessions        List sessions with filtered user sessions
#   --resume <prefix> Resume session by prefix (e.g., --resume a8f5)
#   --keep <prefix>   Protect session from cleanup
#   --unkeep <prefix> Remove protection from session
#   --cleanup         Remove old workspaces (respects workday logic)
#   --remove <name>   Remove specific workspace
#   --version         Show version and Claude Code compatibility
#   --help            Show this help message

set -euo pipefail

WORKSPACE_CLAUDE_VERSION="2.1.0"
WORKSPACE_CLAUDE_TESTED_WITH="2.1.19"

# Auto-detect project root (first parent with .jj or .git)
find_project_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/.jj" ]] || [[ -d "$dir/.git" ]]; then
            echo "$dir"
            return 0
        fi
        dir="$(dirname "$dir")"
    done
    echo "$PWD"
}

PROJECT_ROOT="$(find_project_root)"
PROJECT_NAME="$(basename "$PROJECT_ROOT")"
WORKSPACES_DIR="${PROJECT_ROOT}-workspaces"
KEEP_WORKDAYS="${KEEP_WORKDAYS:-2}"  # Keep sessions from last N workdays (Mon-Fri)

log_info() { echo -e "\033[0;32m[workspace]\033[0m $1" >&2; }
log_warn() { echo -e "\033[1;33m[workspace]\033[0m $1" >&2; }
log_error() { echo -e "\033[0;31m[workspace]\033[0m $1" >&2; }

show_help() {
    cat << 'EOF'
workspace-claude - Launch Claude in isolated jj workspace

USAGE:
    workspace-claude [options] [claude-args...]

OPTIONS:
    --branch <rev>    Base workspace on specific revision (default: main)
    --list            List active workspaces with filesystem age
    --sessions        List sessions with claude-mem context (richer info)
    --resume <prefix> Resume existing session by prefix (e.g., --resume a8f5)
    --keep <prefix>   Protect session from automatic cleanup
    --unkeep <prefix> Remove protection from session
    --cleanup         Remove old workspaces (respects workday logic + keep flag)
    --remove <name>   Remove specific workspace
    --help            Show this help message

ENVIRONMENT:
    KEEP_WORKDAYS     Number of workdays to keep sessions (default: 2)
                      Workdays = Mon-Fri, so Friday sessions survive Monday cleanup

EXAMPLES:
    workspace-claude                    # Start new session
    workspace-claude --sessions         # List sessions with context
    workspace-claude --resume a8f5      # Resume session by prefix
    workspace-claude --keep a8f5        # Protect session from cleanup
    workspace-claude --branch feat/x    # Start from specific branch

SESSION METADATA:
    Each workspace has a .session-meta.json with:
    - created: Creation timestamp
    - last_active: Last activity timestamp
    - description: Optional description
    - keep: Protection flag (survives cleanup if true)

VERSION:
    workspace-claude $WORKSPACE_CLAUDE_VERSION
    Tested with Claude Code $WORKSPACE_CLAUDE_TESTED_WITH
EOF
}

show_version() {
    echo "workspace-claude $WORKSPACE_CLAUDE_VERSION"
    echo "Tested with: Claude Code $WORKSPACE_CLAUDE_TESTED_WITH"
    echo ""

    # Check current Claude Code version
    local current_cc_version
    current_cc_version=$(command claude --version 2>/dev/null | head -1 | grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+' || echo "unknown")

    echo "Installed Claude Code: $current_cc_version"

    # Compare versions
    if [[ "$current_cc_version" != "unknown" && "$current_cc_version" != "$WORKSPACE_CLAUDE_TESTED_WITH" ]]; then
        echo ""
        echo "âš ï¸  Version mismatch detected!"
        echo "   Check CHANGELOG.md for compatibility notes:"
        echo "   https://github.com/Benniphx/workspace-isolation-guide/blob/main/CHANGELOG.md"
    fi
}

# Calculate cutoff date based on workdays (Mon-Fri)
# Returns Unix timestamp of the cutoff date
calculate_cutoff_date() {
    local keep_days="${1:-$KEEP_WORKDAYS}"
    local now_ts=$(date +%s)
    local day_of_week=$(date +%u)  # 1=Monday, 7=Sunday
    local days_to_subtract=0
    local workdays_counted=0

    # Count backwards through calendar days until we've passed enough workdays
    while [[ $workdays_counted -lt $keep_days ]]; do
        ((days_to_subtract++))
        local check_ts=$((now_ts - days_to_subtract * 86400))
        local check_dow=$(date -r "$check_ts" +%u 2>/dev/null || date -d "@$check_ts" +%u 2>/dev/null)
        # Only count Mon-Fri as workdays
        if [[ $check_dow -ge 1 && $check_dow -le 5 ]]; then
            ((workdays_counted++))
        fi
    done

    # Return timestamp at start of the cutoff day
    local cutoff_ts=$((now_ts - days_to_subtract * 86400))
    # Normalize to start of day
    local cutoff_date=$(date -r "$cutoff_ts" +%Y-%m-%d 2>/dev/null || date -d "@$cutoff_ts" +%Y-%m-%d 2>/dev/null)
    date -j -f "%Y-%m-%d" "$cutoff_date" +%s 2>/dev/null || date -d "$cutoff_date" +%s 2>/dev/null
}

# Create session metadata file
create_session_meta() {
    local workspace_path="$1"
    local session_id="$2"
    local meta_file="${workspace_path}/.session-meta.json"

    cat > "$meta_file" << EOF
{
  "created": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "last_active": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "description": "",
  "keep": false,
  "session_id": "$session_id"
}
EOF
}

# Update session metadata field
update_session_meta() {
    local workspace_path="$1"
    local field="$2"
    local value="$3"
    local meta_file="${workspace_path}/.session-meta.json"

    if [[ ! -f "$meta_file" ]]; then
        log_warn "No metadata file found: $meta_file"
        return 1
    fi

    # Use jq if available, otherwise sed for simple cases
    if command -v jq &>/dev/null; then
        local tmp_file=$(mktemp)
        if [[ "$value" == "true" || "$value" == "false" ]]; then
            jq ".$field = $value" "$meta_file" > "$tmp_file"
        else
            jq ".$field = \"$value\"" "$meta_file" > "$tmp_file"
        fi
        mv "$tmp_file" "$meta_file"
    else
        # Fallback: simple sed for common cases
        if [[ "$field" == "keep" ]]; then
            sed -i.bak "s/\"keep\": [^,]*/\"keep\": $value/" "$meta_file"
            rm -f "${meta_file}.bak"
        elif [[ "$field" == "last_active" ]]; then
            sed -i.bak "s/\"last_active\": \"[^\"]*\"/\"last_active\": \"$value\"/" "$meta_file"
            rm -f "${meta_file}.bak"
        fi
    fi
}

# Read session metadata field
read_session_meta() {
    local workspace_path="$1"
    local field="$2"
    local meta_file="${workspace_path}/.session-meta.json"

    if [[ ! -f "$meta_file" ]]; then
        echo ""
        return
    fi

    if command -v jq &>/dev/null; then
        jq -r ".$field // empty" "$meta_file" 2>/dev/null
    else
        # Fallback: grep for simple cases
        grep -o "\"$field\": *\"[^\"]*\"" "$meta_file" 2>/dev/null | sed 's/.*: *"\([^"]*\)"/\1/' || \
        grep -o "\"$field\": *[^,}]*" "$meta_file" 2>/dev/null | sed 's/.*: *//' | tr -d ' '
    fi
}

# Find workspace by prefix
find_workspace_by_prefix() {
    local prefix="$1"
    local matches=()

    [[ -d "$WORKSPACES_DIR" ]] || return 1

    for ws in "$WORKSPACES_DIR"/session-*"$prefix"*; do
        [[ -d "$ws" ]] && matches+=("$ws")
    done

    if [[ ${#matches[@]} -eq 0 ]]; then
        log_error "No workspace found matching: $prefix"
        return 1
    elif [[ ${#matches[@]} -gt 1 ]]; then
        log_error "Multiple workspaces match '$prefix':"
        for m in "${matches[@]}"; do
            echo "  $(basename "$m")" >&2
        done
        return 1
    fi

    echo "${matches[0]}"
}

# Set/unset keep flag on session
keep_session() {
    local prefix="$1"
    local keep_value="${2:-true}"

    local workspace_path
    workspace_path=$(find_workspace_by_prefix "$prefix") || return 1

    local meta_file="${workspace_path}/.session-meta.json"
    if [[ ! -f "$meta_file" ]]; then
        # Create metadata if missing
        local session_id=$(basename "$workspace_path")
        create_session_meta "$workspace_path" "$session_id"
    fi

    update_session_meta "$workspace_path" "keep" "$keep_value"
    update_session_meta "$workspace_path" "last_active" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

    if [[ "$keep_value" == "true" ]]; then
        log_info "Protected: $(basename "$workspace_path")"
    else
        log_info "Unprotected: $(basename "$workspace_path")"
    fi
}

# Check if session is a real user session (not memory-observer, sub-agent, or system)
is_user_session() {
    local first_prompt="$1"
    local msg_count="$2"

    # Filter out empty or very short sessions
    [[ -z "$first_prompt" ]] && return 1
    [[ "$first_prompt" == "No prompt" ]] && return 1
    [[ "${msg_count:-0}" -lt 3 ]] && return 1

    # Filter out memory-observer sessions
    if [[ "$first_prompt" == *"Claude-Mem"* ]] || \
       [[ "$first_prompt" == *"memory agent"* ]] || \
       [[ "$first_prompt" == *"observer"* ]] || \
       [[ "$first_prompt" == *"observed_from_primary"* ]] || \
       [[ "$first_prompt" == *"You are a specialized"* ]]; then
        return 1
    fi

    # Filter out task notifications and system messages
    if [[ "$first_prompt" == "<task-notification>"* ]] || \
       [[ "$first_prompt" == "PROGRESS SUMMARY"* ]] || \
       [[ "$first_prompt" == *"<what_"* ]]; then
        return 1
    fi

    return 0
}

# List sessions from all workspaces with filtering
list_sessions() {
    echo "$PROJECT_NAME Workspace Sessions"
    echo "=================================="
    echo ""
    printf "  %-19s | %-7s | %-11s | %-4s | %-6s | %s\n" "Workspace" "Status" "Modified" "Msgs" "Keep" "First Prompt"
    printf "  %-19s-+-%-7s-+-%-11s-+-%-4s-+-%-6s-+-%s\n" "-------------------" "-------" "-----------" "----" "------" "----------------------------------------"

    local sessions_found=false
    local claude_projects_dir="$HOME/.claude/projects"
    local seen_workspaces=()

    # Scan all workspace session indices
    for index_dir in "$claude_projects_dir"/-*-"${PROJECT_NAME}-workspaces-session-"*; do
        [[ -d "$index_dir" ]] || continue
        local index_file="$index_dir/sessions-index.json"
        [[ -f "$index_file" ]] || continue

        # Extract workspace ID from directory name
        local workspace_id=$(basename "$index_dir" | grep -o 'session-[0-9]*-[a-f0-9]*' | head -1)
        [[ -z "$workspace_id" ]] && continue

        local short_id="${workspace_id#session-}"
        local workspace_path="${WORKSPACES_DIR}/${workspace_id}"

        # Check workspace status
        local ws_status="orphan"
        local keep_flag="no"
        if [[ -d "$workspace_path" ]]; then
            ws_status="active"
            keep_flag=$(read_session_meta "$workspace_path" "keep")
            [[ "$keep_flag" == "true" ]] && keep_flag="YES" || keep_flag="no"
        fi

        # Parse sessions-index.json for real user sessions (only show most recent per workspace)
        if command -v jq &>/dev/null; then
            local best_session=""
            local best_msg_count=0
            local best_modified=""
            local best_prompt=""

            while IFS='|' read -r first_prompt msg_count modified; do
                [[ -z "$first_prompt" ]] && continue

                # Filter out memory-observer and sub-agent sessions
                if ! is_user_session "$first_prompt" "$msg_count"; then
                    continue
                fi

                # Keep the session with most messages (likely the main conversation)
                if [[ "${msg_count:-0}" -gt "$best_msg_count" ]]; then
                    best_msg_count="$msg_count"
                    best_modified="$modified"
                    best_prompt="$first_prompt"
                fi

            done < <(jq -r '.entries[] | "\(.firstPrompt | gsub("\n"; " ")[:100])|\(.messageCount)|\(.modified)"' "$index_file" 2>/dev/null)

            # Only show if we found a valid session
            if [[ -n "$best_prompt" ]]; then
                sessions_found=true

                # Format date from ISO timestamp
                local mod_date=$(echo "$best_modified" | cut -d'T' -f1)

                # Truncate first prompt for display
                local prompt_preview="${best_prompt:0:40}"
                [[ ${#best_prompt} -gt 40 ]] && prompt_preview="${prompt_preview}..."

                printf "  %-19s | %-7s | %-11s | %4s | %-6s | %s\n" \
                    "$short_id" "$ws_status" "$mod_date" "$best_msg_count" "$keep_flag" "$prompt_preview"
            fi
        else
            # Fallback without jq - just show workspace exists
            sessions_found=true
            local date_part="${short_id:0:8}"
            local formatted_date="${date_part:0:4}-${date_part:4:2}-${date_part:6:2}"
            printf "  %-19s | %-7s | %-11s | %4s | %-6s | %s\n" \
                "$short_id" "$ws_status" "$formatted_date" "?" "$keep_flag" "(install jq for details)"
        fi
    done

    # Also list workspaces without Claude sessions yet
    if [[ -d "$WORKSPACES_DIR" ]]; then
        for ws in "$WORKSPACES_DIR"/session-*; do
            [[ -d "$ws" ]] || continue
            local ws_name=$(basename "$ws")
            local short_id="${ws_name#session-}"

            # Check if we already listed this workspace
            local index_dir="$claude_projects_dir/-Users-benniphx-Documents-jobrad-${PROJECT_NAME}-workspaces-${ws_name}"
            [[ -d "$index_dir" ]] && continue

            sessions_found=true
            local keep_flag=$(read_session_meta "$ws" "keep")
            [[ "$keep_flag" == "true" ]] && keep_flag="YES" || keep_flag="no"

            local date_part="${short_id:0:8}"
            local formatted_date="${date_part:0:4}-${date_part:4:2}-${date_part:6:2}"

            printf "  %-19s | %-7s | %-11s | %4s | %-6s | %s\n" \
                "$short_id" "new" "$formatted_date" "0" "$keep_flag" "(no sessions yet)"
        done
    fi

    if [[ "$sessions_found" == "false" ]]; then
        echo "  (no sessions found)"
    fi

    echo ""
    echo "Legend: active = workspace exists, orphan = workspace deleted, new = no Claude sessions yet"
    echo ""
    echo "Resume with: workspace-claude --resume <prefix>"
}

# Resume existing session
resume_session() {
    local prefix="$1"
    shift
    local claude_args=("$@")

    local workspace_path
    workspace_path=$(find_workspace_by_prefix "$prefix") || return 1

    local session_id=$(basename "$workspace_path")

    echo "ðŸ”„ Resuming Workspace Session"
    echo "   Project: $PROJECT_NAME"
    echo "   Session: ${session_id#session-}"
    echo ""

    # Update last_active
    if [[ -f "${workspace_path}/.session-meta.json" ]]; then
        update_session_meta "$workspace_path" "last_active" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
    fi

    echo "ðŸ“ Workspace: $workspace_path"

    # Set BEADS_DIR if project has beads
    if [[ -d "$PROJECT_ROOT/.beads" ]]; then
        export BEADS_DIR="$PROJECT_ROOT/.beads"
        echo "ðŸ“‹ Beads: $BEADS_DIR (central)"
    fi

    echo ""

    cd "$workspace_path"
    eval "$(mise activate bash 2>/dev/null)" || true
    direnv allow 2>/dev/null || true

    # Resume with --resume flag to continue conversation
    exec command claude --dangerously-skip-permissions --resume ${claude_args[@]+"${claude_args[@]}"}
}

cleanup_old_workspaces() {
    [[ -d "$WORKSPACES_DIR" ]] || return 0

    # Auto-recover stale working copy before cleanup (uses jj workspace forget)
    if jj st 2>&1 | grep -q "working copy is stale"; then
        jj workspace update-stale 2>/dev/null || true
    fi

    local count=0
    local skipped=0
    local cutoff_ts
    cutoff_ts=$(calculate_cutoff_date "$KEEP_WORKDAYS")

    log_info "Cleanup: keeping sessions from last $KEEP_WORKDAYS workday(s)"
    log_info "Cutoff date: $(date -r "$cutoff_ts" +%Y-%m-%d 2>/dev/null || date -d "@$cutoff_ts" +%Y-%m-%d 2>/dev/null)"

    for ws in "$WORKSPACES_DIR"/session-*; do
        [[ -d "$ws" ]] || continue
        local ws_name=$(basename "$ws")

        # Check keep flag in metadata
        local keep_flag=$(read_session_meta "$ws" "keep")
        if [[ "$keep_flag" == "true" ]]; then
            log_info "Keeping (protected): $ws_name"
            ((skipped++)) || true
            continue
        fi

        # Use last_active from metadata if available, otherwise filesystem mtime
        local last_active=$(read_session_meta "$ws" "last_active")
        local ws_ts

        if [[ -n "$last_active" ]]; then
            # Parse ISO date from metadata
            ws_ts=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$last_active" +%s 2>/dev/null || \
                    date -d "$last_active" +%s 2>/dev/null || \
                    stat -f %m "$ws" 2>/dev/null || stat -c %Y "$ws" 2>/dev/null)
        else
            ws_ts=$(stat -f %m "$ws" 2>/dev/null || stat -c %Y "$ws" 2>/dev/null)
        fi

        if [[ $ws_ts -lt $cutoff_ts ]]; then
            log_info "Removing old workspace: $ws_name"
            (cd "$PROJECT_ROOT" && jj workspace forget "$ws_name" 2>/dev/null || true)
            rm -rf "$ws"
            ((count++)) || true
        fi
    done

    [[ $count -gt 0 ]] && log_info "Cleaned up $count workspace(s)"
    [[ $skipped -gt 0 ]] && log_info "Skipped $skipped protected workspace(s)"
    return 0
}

create_workspace() {
    local session_id="$1"
    local base_rev="${2:-main}"
    local short_id="${session_id:0:19}"  # YYYYMMDDHHMMSS-xxxx (includes random)
    local workspace_name="session-${short_id}"
    local workspace_path="${WORKSPACES_DIR}/${workspace_name}"

    mkdir -p "$WORKSPACES_DIR"
    cleanup_old_workspaces

    if [[ -d "$workspace_path" ]]; then
        log_info "Workspace exists: $workspace_name"
        echo "$workspace_path"
        return 0
    fi

    log_info "Creating workspace: $workspace_name (based on $base_rev)"

    cd "$PROJECT_ROOT"

    # Auto-recover stale working copy (happens when other workspaces modify the repo)
    # Note: jj config `snapshot.auto-update-stale = true` handles this globally,
    # but we keep explicit recovery as defense-in-depth for safety.
    if jj st 2>&1 | grep -q "working copy is stale"; then
        log_info "Recovering stale working copy..."
        jj workspace update-stale 2>/dev/null || log_warn "Could not update stale working copy"
    fi

    log_info "Fetching latest..."
    jj git fetch 2>/dev/null || {
        # Fallback: fetch without working copy interaction
        jj --ignore-working-copy git fetch 2>/dev/null || log_warn "Could not fetch"
    }

    # Update local main bookmark to match origin (jj fetch doesn't do this automatically)
    if [[ "$base_rev" == "main" ]]; then
        log_info "Syncing main to origin..."
        jj bookmark set main -r main@origin 2>/dev/null || \
            jj --ignore-working-copy bookmark set main -r main@origin 2>/dev/null || \
            log_warn "Could not sync main"
    fi

    jj workspace add "$workspace_path" -r "$base_rev" 2>/dev/null || {
        log_error "Failed to create workspace"
        return 1
    }

    # Copy environment files
    for f in .envrc .env .env.local; do
        [[ -f "$PROJECT_ROOT/$f" ]] && cp "$PROJECT_ROOT/$f" "$workspace_path/"
    done

    # Create session metadata
    create_session_meta "$workspace_path" "$workspace_name"

    cd "$workspace_path"

    # Setup based on project type
    if [[ -f "pyproject.toml" ]]; then
        log_info "Python project - running uv sync..."
        mise trust "$workspace_path" 2>/dev/null || true
        eval "$(mise activate bash 2>/dev/null)" || true
        uv sync >/dev/null 2>&1 || log_warn "uv sync failed"
    elif [[ -f "package.json" ]]; then
        log_info "Node project - running npm install..."
        npm install >/dev/null 2>&1 || log_warn "npm install failed"
    fi

    # Remove macOS extended attributes that block Python execution in sandbox
    # (com.apple.provenance is set when files are copied and can cause [Errno 1])
    find "$workspace_path/.claude" -name "*.py" -exec xattr -d com.apple.provenance {} \; 2>/dev/null || true
    find "$workspace_path/.claude" -name "*.sh" -exec xattr -d com.apple.provenance {} \; 2>/dev/null || true

    log_info "Workspace ready: $workspace_path"
    echo "$workspace_path"
}

list_workspaces() {
    echo "Active workspaces for $PROJECT_NAME:"
    echo "======================================"

    if [[ ! -d "$WORKSPACES_DIR" ]]; then
        echo "  (none)"
        return
    fi

    for ws in "$WORKSPACES_DIR"/session-*; do
        [[ -d "$ws" ]] || continue
        local ws_name=$(basename "$ws")
        local mtime=$(stat -f %m "$ws" 2>/dev/null || stat -c %Y "$ws" 2>/dev/null)
        local age_hours=$(( ($(date +%s) - mtime) / 3600 ))
        echo "  $ws_name (age: ${age_hours}h)"
    done

    echo ""
    echo "jj workspaces:"
    (cd "$PROJECT_ROOT" && jj workspace update-stale 2>/dev/null; jj workspace list 2>/dev/null) || echo "  (not a jj repo)"
}

remove_workspace() {
    local workspace_name="$1"
    local workspace_path="${WORKSPACES_DIR}/${workspace_name}"

    if [[ ! -d "$workspace_path" ]]; then
        log_error "Workspace not found: $workspace_name"
        return 1
    fi

    log_info "Removing: $workspace_name"
    (cd "$PROJECT_ROOT" && jj workspace forget "$workspace_name" 2>/dev/null || true)
    rm -rf "$workspace_path"
    log_info "Done"
}

# Parse arguments
BASE_REV="main"
ACTION="run"
REMOVE_TARGET=""
RESUME_PREFIX=""
KEEP_PREFIX=""
CLAUDE_ARGS=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        --branch)
            BASE_REV="$2"
            shift 2
            ;;
        --list)
            ACTION="list"
            shift
            ;;
        --sessions)
            ACTION="sessions"
            shift
            ;;
        --resume)
            ACTION="resume"
            RESUME_PREFIX="$2"
            shift 2
            ;;
        --keep)
            ACTION="keep"
            KEEP_PREFIX="$2"
            shift 2
            ;;
        --unkeep)
            ACTION="unkeep"
            KEEP_PREFIX="$2"
            shift 2
            ;;
        --cleanup)
            ACTION="cleanup"
            shift
            ;;
        --remove)
            ACTION="remove"
            REMOVE_TARGET="$2"
            shift 2
            ;;
        --version|-v)
            ACTION="version"
            shift
            ;;
        --help|-h)
            ACTION="help"
            shift
            ;;
        *)
            CLAUDE_ARGS+=("$1")
            shift
            ;;
    esac
done

case "$ACTION" in
    help)
        show_help
        ;;
    version)
        show_version
        ;;
    list)
        list_workspaces
        ;;
    sessions)
        list_sessions
        ;;
    resume)
        resume_session "$RESUME_PREFIX" "${CLAUDE_ARGS[@]}"
        ;;
    keep)
        keep_session "$KEEP_PREFIX" "true"
        ;;
    unkeep)
        keep_session "$KEEP_PREFIX" "false"
        ;;
    cleanup)
        cleanup_old_workspaces
        ;;
    remove)
        remove_workspace "$REMOVE_TARGET"
        ;;
    run)
        session_id="$(date +%Y%m%d%H%M%S)-$(openssl rand -hex 4)"

        echo "ðŸš€ Workspace Claude Launcher"
        echo "   Project: $PROJECT_NAME"
        echo "   Session: ${session_id:0:19}"
        echo "   Base: $BASE_REV"
        echo ""

        workspace_path=$(create_workspace "$session_id" "$BASE_REV")

        if [[ ! -d "$workspace_path" ]]; then
            echo "âŒ Failed to create workspace"
            exit 1
        fi

        echo ""
        echo "ðŸ“ Workspace: $workspace_path"

        # Set BEADS_DIR if project has beads
        if [[ -d "$PROJECT_ROOT/.beads" ]]; then
            export BEADS_DIR="$PROJECT_ROOT/.beads"
            echo "ðŸ“‹ Beads: $BEADS_DIR (central)"
        fi

        echo ""

        cd "$workspace_path"
        eval "$(mise activate bash 2>/dev/null)" || true
        direnv allow 2>/dev/null || true

        # Skip trust dialog - workspaces are created from trusted repo
        exec command claude --dangerously-skip-permissions ${CLAUDE_ARGS[@]+"${CLAUDE_ARGS[@]}"}
        ;;
esac
